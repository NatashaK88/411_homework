<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Game</title>
<style>
    canvas {
        border: 1px solid black;
        display: block;
        margin: 0 auto;
    }
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Objects JSON
    let objectsData = [];
    let purpleCircles = [];

    // Player object
    const player = {
        x: 50,
        y: 50,
        width: 50,
        height: 50,
        speed: 5,
        dx: 0,
        dy: 0
    };

    // Score
    let score = 0;

    // Initialize objects
    function initializeObjects() {
        for (let i = 0; i < 5; i++) {
            objectsData.push({
                x: Math.random() * (canvas.width - 50),
                y: Math.random() * (canvas.height - 50),
                width: 50,
                height: 50,
                speedX: Math.random() * 2 + 1, // Random speed in X direction
                speedY: Math.random() * 2 + 1 // Random speed in Y direction
            });
        }

        for (let i = 0; i < 3; i++) {
            purpleCircles.push({
                x: Math.random() * (canvas.width - 30) + 15,
                y: Math.random() * (canvas.height - 30) + 15,
                radius: 15,
                speedX: Math.random() * 2 + 1, // Random speed in X direction
                speedY: Math.random() * 2 + 1 // Random speed in Y direction
            });
        }
    }

    initializeObjects();

    // Draw objects
    function drawObjects() {
        objectsData.forEach(obj => {
            ctx.fillStyle = 'blue';
            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
        });

        ctx.fillStyle = 'purple';
        purpleCircles.forEach(circle => {
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        });
    }

    // Draw player
    function drawPlayer() {
        ctx.fillStyle = 'red';
        ctx.fillRect(player.x, player.y, player.width, player.height);
    }


    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }


    function update() {
        clearCanvas();
        drawObjects();
        drawPlayer();


        player.x += player.dx;
        player.y += player.dy;


        objectsData.forEach(obj => {
            obj.x += obj.speedX;
            obj.y += obj.speedY;


            if (obj.x <= 0 || obj.x + obj.width >= canvas.width) {
                obj.speedX *= -1;
            }
            if (obj.y <= 0 || obj.y + obj.height >= canvas.height) {
                obj.speedY *= -1;
            }
        });

        // Move purple circles
        purpleCircles.forEach(circle => {
            circle.x += circle.speedX;
            circle.y += circle.speedY;


            if (circle.x - circle.radius <= 0 || circle.x + circle.radius >= canvas.width) {
                circle.speedX *= -1;
            }
            if (circle.y - circle.radius <= 0 || circle.y + circle.radius >= canvas.height) {
                circle.speedY *= -1;
            }
        });

        // Check collision with objects
        objectsData.forEach(obj => {
            if (checkCollision(player, obj)) {
                // If collision detected, adjust player position to prevent overlap
                let dx = (player.x + player.width / 2) - (obj.x + obj.width / 2);
                let dy = (player.y + player.height / 2) - (obj.y + obj.height / 2);
                let penetration = Math.abs(dx) - (player.width / 2 + obj.width / 2);
                if (dx < 0) player.x += penetration;
                else player.x -= penetration;
                penetration = Math.abs(dy) - (player.height / 2 + obj.height / 2);
                if (dy < 0) player.y += penetration;
                else player.y -= penetration;
            }
        });

        // Check collision with purple circles
        for (let i = 0; i < purpleCircles.length; i++) {
            let circle = purpleCircles[i];
            let distance = Math.sqrt(Math.pow(player.x - circle.x, 2) + Math.pow(player.y - circle.y, 2));
            if (distance < player.width / 2 + circle.radius) {
                purpleCircles.splice(i, 1);
                score++;
                i--;
            }
        }

        // Display score
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText('Score: ' + score, 10, 30);

        requestAnimationFrame(update);
    }


    function checkCollision(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.width > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.height > obj2.y;
    }


    document.addEventListener('keydown', event => {
        switch (event.keyCode) {
            case 37: // Left
                player.dx = -player.speed;
                break;
            case 38: // Up
                player.dy = -player.speed;
                break;
            case 39: // Right
                player.dx = player.speed;
                break;
            case 40: // Down
                player.dy = player.speed;
                break;
        }
    });

    
    document.addEventListener('keyup', event => {
        switch (event.keyCode) {
            case 37: // Left
            case 39: // Right
                player.dx = 0;
                break;
            case 38: // Up
            case 40: // Down
                player.dy = 0;
                break;
        }
    });

    // Start the game loop
    update();
</script>
</body>
</html>
